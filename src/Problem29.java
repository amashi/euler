import java.math.BigDecimal;
import java.math.BigInteger;


public class Problem29 {

	/**
	 * 
    Consider all integer combinations of a^(b) for 2 <= a <=  5 and 2 <= b  <= 5:

    2^(2)=4, 2^(3)=8, 2^(4)=16, 2^(5)=32
    3^(2)=9, 3^(3)=27, 3^(4)=81, 3^(5)=243
    4^(2)=16, 4^(3)=64, 4^(4)=256, 4^(5)=1024
    5^(2)=25, 5^(3)=125, 5^(4)=625, 5^(5)=3125

	If they are then placed in numerical order, with any repeats removed, 
	we get the following sequence of 15 distinct terms:
	
	4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
	
	How many distinct terms are in the sequence generated by a^(b) for 2 <= a  <=100 and 2 <=b<=  100?
	 */

	public static void main(String[] args) {
	
		
		Problem29 p = new Problem29(); 
		p.run();
		
		
		

	}

	
	private void run() {

		conwayPrimeGenerator();
		
	}


	/*
	 Start with the number 2 as your seed. Multiply it by each of the fractions above, 
	 in order, until you find one that produces an integer. (It’s 15/2.) Now adopt that integer (15) as the new seed, 
	 and multiply that by each of the fractions until you produce another integer. Keep this up, 
	 making a note whenever you produce a power of 2.

     The first such power (4, or 22) appears after 19 steps. 
     Fifty steps later, 23 turns up. Then 25 appears about 200 steps further on. 
     A pattern emerges: the exponents are 2, 3, 5 …

	 It turns out that “these fourteen fractions alone have it in them to produce an infinity of primes, 
	 even those that no one yet knows about,” writes Dominic Olivastro. 
	 “There is something enormously magical about it.” John Horton Conway devised the technique; 
	 it’s an instance of his Fractran computing algorithm.
	 */
	private void conwayPrimeGenerator() {

		
		 
		BigDecimal c = new BigDecimal("15");  
		BigDecimal d = new BigDecimal("2");
	   
		BigDecimal m = c.divide(d, 200, BigDecimal.ROUND_FLOOR); 
			
		
		
		System.out.println(m); 
		
		
		
		
	}

}
