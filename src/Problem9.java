import java.util.*;

/**
 * A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
 * a^(2) + b^(2) = c^(2)
 * <p/>
 * For example, 3^(2) + 4^(2) = 9 + 16 = 25 = 5^(2).
 * <p/>
 * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
 * Find the product abc.
 */
public class Problem9 {
    public static void main(String[] args)
    {
        /*
        Euclid's formula
        given m and n with m > n

        a = 2mn
        b = m^2 - n^2
        c = m^2 + n^2 
        The triple generated by Euclid's formula is
        primitive if and only if m and n
        are coprime and exactly one of them is even

        Given an integer n, the triple can be generated by the following two procedures
        given n...

        a = 2n + 1
        b = 2n(n+1);
        c = 2n(n+1)+1;

        Alternatively, one can generate triples from even integers using the following formulas:
        a = 2m
        b = m^2 - 1
        c = m^2 + 1

        Example: When m = 4 the triple produced is 8, 15, and 17
        (This formula is another specific case of method I, substituting n with 1).

        */


//        for(int i =0; i<100; i++){
//
//            System.out.print("generated triple from n=" + i + "    ");
//            int sum = phyTriples(i+1);
//            System.out.println("   sum=" + sum );
//        }

//        TreeSet<Integer> f = factorize(1000);
//
//        if (f.size() == 1)
//        {
//            System.out.println("prime number =" + f.first());
//        } else
//            for (Iterator<Integer> integerIterator = f.iterator(); integerIterator.hasNext();)
//            {
//                Integer fac = integerIterator.next();
//                System.out.println("factor = " + fac);
//            }
//

//        int c = GCD(81, 18);
//        System.out.println("c = " + c);

        primitivePhyTriples(100);
    }


    /**
     * @param
     * @return Euclid's formula
     *         given m and n with m > n
     *         <p/>
     *         a = 2mn
     *         b = m^2 - n^2
     *         c = m^2 + n^2
     *         <p/>
     *         The triple generated by Euclid's formula is
     *         primitive if and only if m and n
     *         are coprime and exactly one of them is even
     */
    public static void primitivePhyTriples(int upTo)
    {
        int a, b, c;
        int m = 0, n = 0;

        Map<Integer, String> set = Collections.synchronizedMap(new HashMap<Integer,String>());
           ArrayList<Integer> al = new ArrayList<Integer>();

//        HashMap<Integer,String> set = new HashMap<Integer, String>();

        for (int i = 0; i < upTo; i++)
        {
            for (int x = 0; x < upTo; x++)
            {
                if (x > i)
                {
                    m = x + 1;
                    n = i + 1;
                }
                else
                {
                    n = x + 1;
                    m = i + 1;
                }
                if (readyPhyPrimPair(m, n))
                {
                    a = 2 * m * n;
                    b = (m * m) - (n * n);
                    c = (m * m) + (n * n);

                    int sum = (a + b + c);
                    System.out.println("PP Triple based on (" + m + "," + n + ") " + a + "," + b + "," + c + " sum=" + sum);
                   // System.out.println("sum = " + sum);
                  //  if(!set.containsKey(sum))
//                    if(!al.contains(sum))
//                    {
//                        al.add(sum);
//                    //    set.put(sum, "PP Triple based on (" + m + "," + n + ") " + a + "," + b + "," + c + " sum=" + sum);
//                    }


                }
            }
//            PP Triple 44,483,485 Sum=1012
            Collections.sort(al);
            for (int j = 0; j < al.size(); j++)
            {
                Integer integer = al.get(j);
                System.out.println("sum = " + integer);
            }


            //   1936  233289  235225
//            PP Triple based on (10,40) 800,-1500,1700 Sum=1000
            Set<Integer> sums = set.keySet();

            for (Iterator<Integer> integerIterator = sums.iterator(); integerIterator.hasNext();)
            {
                Integer sum = integerIterator.next();
                //System.out.println(set.get(sum));
               // System.out.println("sum = " + sum);
                if(sum> 990 && sum< 1013)
                {
                    String val = set.get(sum);
                    System.out.println(val);
                }

            }

            //PP Triple based on (16,15) 480,31,481 sum=992
            //PP Triple based on (22,1) 44,483,485 sum=1012
            //Triple based on (20,5) 200,375,425 sum=1000




        }

        // M > N
//        m = 40; //ONE MUST BE EVEN! to be a primite triple
//        n = 10;
//
//        a = 2 * m * n;
//        b = (m * m) - (n * n);
//        c = (m * m) + (n * n);
//
//        int sum = (a + b + c);
//
//        System.out.println("PP Triple based on (" + m + "," + n + ") " + a + "," + b + "," + c + " Sum=" + sum);


    }


    public static boolean readyPhyPrimPair(int m, int n)
    {
        if (m <= n)
            return false;


//        if (GCD(m, n) == 1)
//        {
//            if (m % 2 == 0 && n % 2 != 0)
//                return true;
//            else if (n % 2 == 0 && m % 2 != 0)
//                return true;
//        }

        return true;
    }

    /**
     * @param n
     * @return the sum
     */
    public static int phyTriples(int n)
    {
        int a, b, c;

        a = n * 2 + 1;
        b = 2 * n * (n + 1);
        c = 2 * n * (n + 1) + 1;


        System.out.print("\ta = " + a);
        System.out.print("\tb = " + b);
        System.out.print("\tc = " + c);


        return a + b + c;
    }


    /*


    //if you had some trouble getting the number into a variable
    //see the note at the end on page 2.
    n=”the evil big number”
    factor=2
    lastFactor=1
    while n>1
        if n mod factor=0
        then
            lastFactor=factor
            n=n div factor
            while n mod factor=0
                n=n div factor
        factor=factor+1
    output lastFactor
     */
    public static TreeSet<Integer> factorize(long n)
    {
        TreeSet<Integer> res = new TreeSet<Integer>();
        int factor = 2;

        while (n > 1)
        {
            if (n % factor == 0)
            {
                res.add(factor);
                n /= factor;

                while (n % factor == 0)
                    n /= factor;
            }
            factor++;
        }

        return res;
    }


    public static int GCD(int a, int b)
    {
        if (b == 0)
            return a;
        else
            return GCD(b, a % b);
    }


    public static boolean isPrime(long n)
    {
        int factor = 2;

        while (n > 1)
        {
            if (n % factor == 0)
            {
                n /= factor;

                while (n % factor == 0)
                    n /= factor;
            }
            factor++;
        }

        return factor == n;
    }

}
